[首页](https://github.com/ofdm/dadunzi)

### 变量声明和定义的区别
1. 声明规定变量类型和名字，不分配内存空间，变量可以声明多次，关键词extern
2. 定义分配内存空间，只能定义一次，extern语句包含初始值就不是声明而是定义

### strlen和sizeof区别
1. sizeof是运算符，不是函数，结果在编译时而非运行时得到，所以不能用来得到动态分配的储存空间大小
2. strlen是字符处理的库函数，其参数只能是字符指针且要以‘\0’结尾的字符
```
int strlen(const char *str)
{
    assert(str! = NULL)
    int length = 0;
    while(*str++!='\0')
        length++;
    return length;
}
```
```
char *strcpy(char *strDest,const char *strSrc)
{
    assert((strSrc != NULL)&&(strDest != NULL);
    char *p = strDest;
    while((*strDest++ = *strSrc++) != '\0')
    return p;
}
```

### 类对象的深拷贝和浅拷贝
1. 浅拷贝：类的成员变量不会开辟内存，利用拷贝构造函数发生对象复制
2. 深拷贝：类的成员开辟内存，需要拷贝构造函数也要开辟新内存进行对象复制，否者两者指向同一内存，当一个对象释放后，另一个对象的指针就变成野指针
### 内存对齐
```
struct test1{
    int a;     //4byte
    double b;  //8byte
    char c;    //1byte
    short d;   //2byte
};
struct test2{
    double b;  //8byte
    int a;     //4byte
    char c;    //1byte
    short d;   //2byte
};
int main()
{
    cout<<sizeof(test1)<<endl; //24byte
    cout<<sizeof(test2)<<endl; //16byte
}
```
按最大Size成员内存对齐

### static的作用，在C和C++中有什么区别
1. static全局变量和函数仅在本文件具有全局可见性，也就是限定了访问域；
2. static局部变量只在第一次被调用时被定义，生命周期直到程序运行结束,但函数外部是不能访问该变量的；
3. 未初始化时，static变量默认值为0。

C++中：
1. 类的静态成员属于整个类而非类的对象，
2. 类的静态成员函数也属于整个类而非类的某个对象，它没有this指针，它无法访问非静态成员和非静态成员函数。

### malloc与new的区别
1. malloc和free时标准库函数，支持覆盖；new和delete时运算符，支持重载；
2. malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。
3. malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。

### 指针和引用的区别
1. 引用只是别名，不占用具体储存空间，它只有声明没有定义，声明时必须初始化另一个变量且不能再做改变（变量可被引用多次，但引用只能做一个变量的引用），引用的类型必须是一个对象，不存在指向空值的引用；
2. 指针是具体变量，占用储存空间（指针大小：32位机4byte，64位8byte），指针的声明和定义可以分开，非常量指针可以重新指向别的变量地址，指针可以指向空值。
```
int a = 10;
//指向常量的指针  常量指针
const int *p1 = &a;
int const *p2 = &a;
//指针常量
int* const p3 = &a;
//指向常量的常量指针
const int* const p4 = &a; 

//指针的引用
const int *&r1 = p1;
int* const &r2 = p3;
const int* const &r3 = p4;
```

### 宏定义与函数，内联函数，const，typedef的区别
1. 宏在编译阶段前完成替换，运行时不发生函数调用，运行更快；宏函数的参数没有类型，不进行类型检查；宏定义的数据没有分配空间；宏不是语句，最后不加分号
2. 函数调用在运行时跳转到具体调用函数，函数参数具有类型，需要类型检查
3. 内敛函数遵循函数一切规则，但内涵函数会内嵌到调用它的程序代码中，避免了函数调用付出的开销，但是复杂结构（循环、条件等）的函数即使指定它为内敛函数还是会当成普通函数处理
4. const作用于编译阶段，会进行类型检查，const变量只是值不能改变，需要分配空间
5. typedef主要用于定义类型别名，它是编译的一部分会进行类型检查；结尾要以分号结束；C++11规定了新的方法，using关键字，注意对指针操作
```
//下面等价
using I = int;
typeddef int I;

//注意指针typedef和#define的区别
typedef char *p;
//using p = char*; //两者相同
const p c1 = 0;  //c是常量指针
//等价于
char* const c1 = 0;
//而不是
const char *c1 = 0;

#define pp char*
const pp c2 = 0;  //pp是指向常量的指针
//等价于
const char *c2 = 0;
//而不是
char* const c2 = 0;
```

### 区别以下指针类型
```
int *p[10];
int (*p)[10];
int *p(int);
int (*p)(int);
```
1. 表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
2. 表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
3. 函数声明，函数名是p，参数是int类型的，返回值是int * 类型的
4. 函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的

### volatile的作用
volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。

### 数组名和指针（这里为指向数组首元素的指针）区别
1. 二者均可通过增减偏移量来访问数组中的元素
2. 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作
3. 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了

### 野指针和空悬指针是什么
产生及解决方法：
野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空
空悬指针：指针free或delete之后没有及时置空 => 释放操作后立即置空

### 堆和栈的区别
1. 申请方式不同：
栈由系统自动分配。
堆由程序员手动分配。
2. 申请大小限制不同：
栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。
堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。
3. 申请效率不同：
栈速度快，不会有碎片。
堆速度慢，且会有碎片。